---
layout: post
title: Java基础八股知识总结
subtitle: ...
date: 2024-01-20
author: Wu
header-img: ../article_img/kb_1.jpg
catalog: true
tags:
  - Java
  - 八股文
---

## 1. **重载和重写的区别？**

重载：发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

重写：方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。

如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。构造方法无法被重写

发生阶段不同，重载发生在编译期，重写发生在运行期。

## 2. 基本类型和包装类型的区别？（延伸问题：包装类的缓存机制、自动装拆箱）

默认值：基本数据类型有默认值，包装类为null
![](../article_img/baseDateDefaultValue.png)


存储方式：都存在堆中。（⚠注意：基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的成员变量 如果没有被 static 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。）

占用空间：相比包装类，基本数据类型占用小

比较方式：包装类用equals，基本数据类型用==

包装类缓存机制：

**Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。**

## 3. 自动装箱与拆箱了解吗？原理是什么？

装箱：将基本类型用它们对应的引用类型包装起来；

拆箱：将包装类型转换为基本数据类型；

举例：Integer i = 10;  _//装箱_int n = i;   _//拆箱_

## 4. 浮点数的精度损失原因？

由于计算机存储浮点数的存储机制有关，十进制0.2转成二进制，出现无限循环小数就会被截断影响精度。

-如何解决浮点数运算的精度丢失问题？

  BigDecimal的使用

创建：BigDecimal(String val)构造方法或

BigDecimal.valueOf(double val) 静态方法来创建对象。add 方法用于将两个 BigDecimal 对象相加

subtract 方法用于将两个 BigDecimal 对象相减。

multiply 方法用于将两个 BigDecimal 对象相乘

divide 方法用于将两个 BigDecimal 对象相除。

a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1 表示 a 大于 b。保留几位小数BigDecimal n = m.setScale(3,RoundingMode.HALF_DOWN);

**-**[**工具类**](#bigdecimal-%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%86%E4%BA%AB)

-超过 long 整型的数据应该如何表示？

**Long最长的64位使用****BigDecimal****其实底层用int****[]****。**

## 5. 面向对象和面向过程的区别

面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。

面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

## 6. 接口类和抽象类的区别 ？

共同点：

l 都不能被实例化。

l 都可以包含抽象方法。

l 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。

区别：

l 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。

l 一个类只能继承（extends）一个类，但是可以实现（implements）多个接口。

l 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

## 7. **深拷贝和浅拷贝的区别？**

![](../article_img/deepAndPlainCopy.png)
## 8. **Java加载的最核心的类是什么？**

Java加载的最核心的类是java.lang.Object。所有的Java类都直接或间接地继承自Object类。Object类提供了一些基本的方法，如equals、hashCode、toString等，因此它是整个类继承体系的根。

当Java虚拟机加载一个类时，它首先加载Object类，然后再加载其他类。因此，Object类在Java类加载机制中具有特殊的地位，被认为是加载的最核心的类。

## 9. equals和 == 的区别

## 10.  **为什么重写 equals() 时必须重写 hashCode() 方法？**

因为Object是所有类的父类，重写的equals方法而不重写hashCode()方法，HashMap和HashSet在集合中存储的对象就不一致。所以重写equals就必须重写hashCode方法。不一致问题会导致数据丢失泄露（指用一个对象查找另外一个对象时由于他们在不一样的hash桶中。在哈希表中，相等的对象应该被散列到相同的哈希桶中，而不是不同的桶中。）

## 11.  String、StringBuffer、StringBuilder 的区别？

可变性

String是不可变的（使用final修饰保存char数组，所以不可变｜Java8中），StringBuffer和StringBuilder是可变的（他们的父类方法AbstractStringBuilder都提供了append方法）

线程安全性

String（不可变，理解为常量，线程安全的）、StringBuffer（加了同步锁，线程安全的）是线程安全的，StringBuilder没有对调用方法加同步锁是非线程安全的。

性能

操作少量的数据: 适用 String

单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder

多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

扩展：Java9中String改用byte存储。（byte 相较 char 节省一半的内存空间）

## 12. String的+本质是什么？

是StringBuilder调用append方法（数组拷贝）和toString方法生成的字符串。

## 13. **String#equals() 和 Object#equals() 有何区别？**

String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。

## 14. **String#intern 方法有什么作用?**

// 在堆中创建字符串对象”Java“

// 将字符串对象”Java“的引用保存在字符串常量池中

String s1 = "Java";

// 直接返回字符串常量池中字符串对象”Java“对应的引用

String s2 = s1.intern();

// 会在堆中在单独创建一个字符串对象

String s3 = new String("Java");

// 直接返回字符串常量池中字符串对象”Java“对应的引用

String s4 = s3.intern();

// s1 和 s2 指向的是堆中的同一个对象

System.out.println(s1 == s2); // true

// s3 和 s4 指向的是堆中不同的对象

System.out.println(s3 == s4); // false

// s1 和 s4 指向的是堆中的同一个对象

System.out.println(s1 == s4); //true

## 15. **Exception异常和Error异常**

Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。分为Checked Exception 和 Unchecked Exception。

Error：程序本无法处理的异常（包括Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等），这些错误发生时，一般虚拟机会主动终止线程。

## 16. **运行时异常和非运行时（受检查异常）异常**

Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。

除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException...。

RuntimeException 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：

NullPointerException(空指针错误)

IllegalArgumentException(参数错误比如方法入参类型错误)

NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）

ArrayIndexOutOfBoundsException（数组越界错误）

ClassCastException（类型转换错误）

ArithmeticException（算术错误）

SecurityException （安全错误比如权限不够）

UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)

……

**扩展：**

[**Throwable 类常用方法有哪些？**](#throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B)

[**try和finally中都有return返回哪个？**](#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8)

## 17. **finally中的代码一定会执行吗？**

catch块中有    System.exit(1);    _// 终止当前正在运行的Java虚拟机_ 

finally就不会执行。

另外，在以下 2 种特殊情况下，finally 块的代码也不会被执行：

程序所在的线程死亡。

关闭 CPU。

## 18. [**如何使用 try-with-resources 代替try-catch-finally？**](#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally)

## 19. [**异常使用有哪些需要注意的地方？**](#%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9)

## 20. **泛型应用场景？**
泛型是指可以应用多种类型的对象的类、接口、方法。

应用场景：Collection中的 sort, binarySearch 方法 / 自定义的 Excel 处理类 ExcelUtil<T> 用于动态指定 Excel 导出的数据类型

## 21. 反射原理？（实现一个自定义日志注解）

通过反射，可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

Java反射机制的原理： Java反射机制是指在运行时，程序可以访问类的内部信息（如类名、属性、方法、构造函数等）并进行操作的能力。

具体原理包括：

Class对象：**每个加载到JVM中的类都会对应一个Class对象**，它是反射的核心入口点。

获取元数据：**通过Class对象获取**，可以获取到该类的所有公共、保护、默认（包访问权限）以及私有字段、方法和构造器的详细信息。

实例化与调用：**反射允许我们创建对象实例**，即使构造函数是私有的；还可以调用任意方法，不论其访问修饰符如何，并且可以修改或读取属性值，突破了编译期静态类型绑定的限制。

运行时类修改：尽管不常见，反射还支持在运行时创建新的类或者修改已有类的结构（例如通过Constructor.newInstance()创建对象，Method.invoke()调用方法，Field.set()设置属性值等）。

### 反射缺点
让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。相关阅读：[Java Reflection: Why is it so slow?open in new window](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)

### 四个反射的方式

```

// 1类.class
Class alunbarClass = TargetObject.class;

// 2传入类的全路径
Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");

// 3通过对象实例获取
TargetObject instance = new TargetObject();
Class alunbarClass2 = instance.getClass();

// 4通过类加载器，传入类的全路径获取（类似2）
ClassLoader.getSystemClasssLoader.loaderClass("cn.javaguide.TargetObject");

```

### [反射基本操作](https://javaguide.cn/java/basis/reflection.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)



## 22. 注解的解析方法有哪几种?

	注解只有被解析之后才会生效，常见的解析方法有两种：

	编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。

	运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。

## 23. SPI机制原理（实现）
	Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 `META-INF` 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，
	然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，
	找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。


## 24.JDK动态代理和CGLIB动态代理
// 待写




## 25.序列化详解
 **序列化**：将数据结构或对象转换成二进制字节流的过程
 **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

### 序列化场景
- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。

### 序列化属于哪一层协议
因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。
![](../article_img/OSI_to_TCPIP.png)
### [常见序列化协议有哪些？](https://javaguide.cn/java/basis/serialization.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)



## [26. unSafe类](https://javaguide.cn/java/basis/unsafe.html)


## 27.Java类的加载机制？


Java类的加载机制主要包括三个步骤：加载（Loading）、链接（Linking）、初始化（Initialization）。

加载（Loading）：通过类加载器将.class文件加载到内存中。

链接（Linking）：分为三个阶段：

验证（Verification）：确保加载的类符合Java虚拟机规范，没有安全方面的问题。

准备（Preparation）：为类的静态变量分配内存，并设置默认初始值。

解析（Resolution）：将类、接口、字段和方法的符号引用解析为直接引用。

初始化（Initialization）：对类的静态变量赋予正确的初始值，执行静态代码块。



# 28.JDK8
## stream流和for的区别？

stream流可以看作是for循环的一个语法糖；

stream有并发流，在超过百万级数据量时，使用stream流效率更高；

## jdk1.8的新特性有哪些？

lamad表达式，stream流，localDate和localDateTime日期类

## localDate和 Date的区别？

localDate 和 localDateTime是对java.util.Date强有力的补充，解决了 Date 类的大部分痛点：

1. 非线程安全
2. 时区处理麻烦
3. 各种格式化、和时间计算繁琐
4. 设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。

## 30. stream流可以收集多次吗？

stream属于管道流，只能消费一次，当第一个stream流调用完毕方法,数据就会流转到下一个Stream上

而这时第一个stream流已经使用完毕，就会关闭了，所以第一个Stream流就不能再调用方法


## stream().map()时，stream是否已经被操作了？

不是，stream流属于惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。

