---
layout: post
title: 开发总结（一）
subtitle: 常用注解、API、工具类...
date: 2024-05-15
author: Wu
header-img: ../article_img/SL_1.jpg
tags:
  - Java
  - Develop
---
## 注解
### Controller层：  
@RestController 
@RequestMapping
@Component
@Controller

### Bean注入/Value注入
@Resource  
@Autowired  
@Value  
用法：  
- 直接把当前字符串赋值给当前字段 @value（“xxx”）
- 占位符的替换，根据操作系统环境变量、jvm环境变量、yml文件等作为替换，赋值给当前字段 @value("$xxx") Q3://先解析Spring表达式，将结果赋值给当前字段。注意：解析表达式得到的有可能是字符串，也有可能是一个bean对象。 @value("#{xxx}") @Qualifier: 当创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，使用@Qualifier 注解和 @Autowired 可以通过指定某一个 bean 的注入来消除歧义。  

### 请求注解
@GetMapping  
@GetMapping(value="/api/manage/test/{sign}")拼参数 参数注解要用@PathVarialble("sign")  
@PostMapping  
@PostMapping("/api/manage/test")一般用与请求参数较多发起Post请求  

### 请求参数
@PathVarialble("sign")  
@RequestParam("id")  
@RequestBody  
@RequestBody直接带Pojo的VO、DTO  
  
### Post和Get的区别  
Post 请求和 Get 请求的主要区别Post 请求和 Get 请求在以下几个方面存在显著的差异:  
1、参数传递方式不同Get 请求的参数附加在 URL 末尾,多个参数用 & 分隔。Post 请求的参数放在请求体中传输。  
2、安全性和隐私性不同Get 请求的参数直接暴露在 URL 中,不安全也缺乏隐私性。Post 请求的参数在请求体中,相对更加安全和隐蔽。3、传输数据量的限制不同Get 请求受限于 URL 的最大长度(通常是 2048 个字符),无法传输大量数据。Post 请求的请求体大小没有限制,可以传输任意量的数据。4、幂等性不同Get 请求是幂等的,多次请求得到的结果是相同的。Post 请求默认是非幂等的,多次请求可能会创建多个资源或产生不同结果。5、可缓存性不同Get 请求的响应可以被浏览器缓存,下次请求时直接使用缓存数据。Post 请求的响应默认不会被浏览器缓存。6、书签和历史记录支持度不同Get 请求的 URL 可以被加入书签,请求参数会被保留。Post 请求的参数不会被保存在书签或浏览器历史记录中。  
  
### Service层  
常用注解：  
@Service
注入注解/属性值注入同上  
@Transactional  
  
### Dao层  
@Mapper  
@Repository  
@Param("")

### Pojo类的注解  
@NoArgsConstructor  
@AllArgsConstructor  
@Data  
@Builder  
@EqualsAndHashCode(callSuper=false)  
@Accessors(chain=true)  
@TableName("")  
@Builder  

### 接口的注解  
@Inherited  
@Documentd  
@Target({ElementType.METHOD,ElementType.Type})  
@Retention

### 属性注解  
@AliasFor
@JsonField()  
@JsonFormate(pattern="yyyy-MM-dd HH:mm:ss")  
@DateTimeFormate(pattern="yyyy-MM-dd HH:mm:ss")  
@TableId(type = "IdType.AUTO")  
@Min(1) 加上该注解的字段必须大于>或等于=指定最小值  
@Size(min = 1, max = 300, groups = {Create.class, Update.class}) 验证对象长度是否在指定范围内。  
@NotBlank  
@NotNull  
@Nullable  
@Validated 经过验证的  

### 其他注解：  
@Aspect  
@Component  
@PointCut("@annotation(path)")  
@Around("")  
@Postconstruct  
@Configuration  
@Bean  
@ConfigurationProperties(prefix="")

### Swagger文档注解  
@Api：修饰整个类，描述Controller的作用  
@ApiOperation：描述一个类的一个方法，或者说一个接口  
@ApiParam：单个参数描述  
@ApiModel：用对象来接收参数  
@ApiModelProperty：用对象接收参数时，描述对象的一个字段  
@ApiResponse：HTTP响应其中1个描述  
@ApiResponses：HTTP响应整体描述  
@ApiIgnore：使用该注解忽略这个API  
@ApiError ：发生错误返回的信息  
@ApiImplicitParam：一个请求参数  
@ApiImplicitParams：多个请求参数

## 集合常用操作
### List

### Map
Map——>AbstractMap——>HashMap

HashMap常用方法：  
1、**put(K key, V value)**： 将键（key）/值（value）映射存放到Map集合中。

2、**get(Object key)**： 返回指定键所映射的值，没有该key对应的值则返回 null。

3、**size()**： 返回Map集合中数据数量。

4、**clear()**： 清空Map集合。

5、**isEmpty()**： 判断Map集合中是否有数据，如果没有则返回true，否则返回false。

6、**remove(Object key)**： 删除Map集合中键为key的数据并返回其所对应value值。

7、**values()**： 返回Map集合中所有value组成的以Collection数据类型格式数据。

8、**containsKey(Object key)**： 判断集合中是否包含指定键，包含返回 true，否则返回false。

9、**containsValue(Object value)**： 判断集合中是否包含指定值，包含返回 true，否则返回false。

10、**keySet()**： 返回Map集合中所有key组成的Set集合。

11、**entrySet()**： 将Map集合每个key-value转换为一个Entry对象并返回由所有的Entry对象组成的Set集合。


  
## Stream流

```java
/*         
	filter：过滤
	forEeach...接续遍历过滤后的数据，进行set操作...
*/     
customerPage.getRecords()  
        .forEach(customer -> customer.getEmployees()  
                .stream()  
                .filter(customerEmployee ->  
                        Objects.nonNull(customerEmployee.getAddWay())).forEach(customerEmployee ->  
                        customerEmployee.setAddWayName(  
                                getCustomerSource(customerEmployee.getAddWay())  
                        )  
                )  
        );
```

```java
// sorted 排序  
List<Student> afterSortedList = lists.stream().sorted(Comparator.comparing(Student::getAge).reversed())  
        .collect(Collectors.toList());  
System.out.println("afterSortedList = " + afterSortedList);  
// limit 限制输出  
long count = lists.stream().limit(1).count();  
System.out.println("count = " + count);
```

```java
//        groupingBy 第一个参数： 分组的字段， 第二个参数： 分则的规则/形式  
//        mapping  第一个参数：映射的字段 ，第二个参数：的规则/形式  
List<String> ids = list.stream()  
        .map(HistoryGainsCategory::getId)  
        .collect(Collectors.toList());  
Map<String, List<HistoryGainsPeriod>> recordMap = historyGainsPeriodMapper.findByCategoryIds(ids)  
        .stream()  
        .collect(Collectors.groupingBy(HistoryGainsPeriod::getCategoryId,  
                Collectors.mapping(p -> p, Collectors.toList())));  
list.stream().filter(t -> recordMap.containsKey(t.getId()))  
        .forEach(t -> t.setPeriods(recordMap.get(t.getId())  
                .stream()  
                .sorted(Comparator.comparing(HistoryGainsPeriod::getEndTime)  
                        .reversed())  
                .limit(1)  
                .collect(Collectors.toList())));
```

```java
// toMap: 两个入参 | 以id为分组，映射一个Map  
Map<String, Student> collect = lists.stream().filter(student -> student.age < 0)  
        .collect(Collectors.toMap(Student::getId, Function.identity()));  
System.out.println("collect = " + collect);

// toMap: 三个参数 | 

//Student::getId：这是方法引用的使用，用来提取每个Student对象的ID作为Map中的键。它等同于student -> student.getId()，但更简洁易读。  
//Function.identity()：正如之前解释的，这个函数表示恒等转换，即输入什么就输出什么，这里用于指定Map的值应该直接使用流中的元素本身（即每个Student对象）。这非常适合你的需求，因为你希望学生对象本身就是Map的值。  
//(oldValue, newValue) -> oldValue：这是当遇到键冲突（即两个学生有相同的ID）时的合并函数（merge function）。这里规定如果发现重复的键，保留旧的值（oldValue）。这意味着如果有两个学生对象有相同的ID，最终Map中将只保留第一次遇到的那个学生对象。  
Map<String, Student> threeMap = lists.stream()  
        .collect(Collectors.toMap(Student::getId,  
                Function.identity(),  
                (oldValue, newValue) -> oldValue));
```

```java
//      joining 第一个参数:分割的符号/字段  
//              第二个参数:集合的首前缀添加字符串 prefix//              第三个参数:集合的尾后缀 添加 suffix  一般填 "," 拼接其他集合  
        String nameLists = lists  
                .stream()  
                .filter(student -> student.age < 0)  
                .map(Student::getName)  
                .collect(Collectors.joining(",","段","++"));  
        System.out.println("nameLists = " + nameLists);
```

[reduce用法](https://link.juejin.cn/?target=https%3A%2F%2Fwww.cnblogs.com%2FMrYuChen-Blog%2Fp%2F14061320.html%23%25E6%2596%25B9%25E5%25BC%258F%25E4%25BA%258Creducet-identity-binaryoperator-accumulator "https://www.cnblogs.com/MrYuChen-Blog/p/14061320.html#%E6%96%B9%E5%BC%8F%E4%BA%8Creducet-identity-binaryoperator-accumulator")

分页操作：


## 原子类使用

## 判断常用API

### Optional用法
```java
List<Object> arrayList = null;  

// 创建一个空的 Optional 对象  
Optional<String> emptyOptional = Optional.empty();  
  
// 创建包含值的 Optional 对象  
Optional<String> nonEmptyOptional = Optional.of("Hello");  
  
// 创建包含可能为空的值的 Optional 对象  
List<Object> objects = Optional.ofNullable(arrayList).orElse(new ArrayList<>());  
System.out.println("objects = " + objects);  
  
//isPresent()：检查值是否存在。  
boolean present = emptyOptional.isPresent();  
System.out.println("present = " + present);  
  
  
//get()：获取值，如果值不存在会抛出 NoSuchElementException 异常。  
String getValue = nonEmptyOptional.get();  
System.out.println("getValue = " + getValue);  
  
  
//orElse(T other)：获取值，如果值不存在则返回指定的默认值。  
String tmd = emptyOptional.orElse("tmd");  
System.out.println("tmd = " + tmd);  
  
  
//orElseGet(Supplier<? extends T> other)：获取值，如果值不存在则返回由 Supplier 提供的默认值。  
Optional<String> nullableOptional = Optional.ofNullable(null);  
System.out.println(nullableOptional.orElse("defaultString。。。"));  
  
String elseGet = nullableOptional.orElseGet(() -> {  
    System.out.println("执行 defaultStr 方法 orElseGet");  
    return "defaultStr";  
});  
System.out.println("elseGet = " + elseGet);
```
### 其他
StringUtils.isNotBlank():判断!=null和!=""  
Objects.isNull():判断为空，!非空  

## 序列换转换util
### Alibaba-[Fastjson](https://www.runoob.com/w3cnote/fastjson-intro.html)
1. Object转换成JSON
```java
String dataJson = (String) datMap.get("data");  
// 转换成jsonObject
JSONObject vo = JSON.parseObject(dataJson, ActivityStatisticsTopVo.class);  
// 转换成json字符串
String paramsString = JSONObject.toJSONString(params);
```
2. JSON转换成集合对象
```java
String json = "[{\"age\":-425370594,\"id\":\"ef7f7639-f672-0fff-8642-76187746bbf6\",\"name\":\"段歧金\"},{\"age\":-1299334324,\"id\":\"6fed763b-f672-0fff-9144-0826d60cf825\",\"name\":\"余阑蠕\"},{\"age\":543170365,\"id\":\"efff763b-f672-0fff-ac22-523ec3ac7e9a\",\"name\":\"万市翟\"},{\"age\":-1603299607,\"id\":\"7fed763b-f672-0fff-b8b5-1ffffa5ab33f\",\"name\":\"邵穷浮\"},{\"age\":1393637743,\"id\":\"ff6d763b-f672-0fff-9d40-709d6588b077\",\"name\":\"吕按挥\"},{\"age\":-1279832129,\"id\":\"ff6f763b-f672-0fff-843f-63c5e8193c79\",\"name\":\"冯穆援\"},{\"age\":1899697129,\"id\":\"6fed763b-f672-0fff-af5d-1eea3a394329\",\"name\":\"姜离述\"},{\"age\":-465857009,\"id\":\"ef7f763b-f672-0fff-81b0-a6f4c9b9a295\",\"name\":\"谢梨碧\"},{\"age\":-1187649426,\"id\":\"effd763b-f672-0fff-ab23-fd02d9b53230\",\"name\":\"史苟训\"},{\"age\":1859746532,\"id\":\"ffff763b-f672-0fff-bb65-90ddbc628711\",\"name\":\"石崩葛\"}]\n";  
List<Student> lists = JSON.parseArray(json, Student.class);  
System.out.println("lists = " + lists);
```
3. 集合转换成JSON
```java
        List<Student> students = new ArrayList<>();
Object json = JSON.toJSON(students,Student.class);  
System.out.println("json = " + json);
```

## 引用传递问题
```java
public class Main {  
  
    public static void main(String[] args) {  
        // write your code here  
        int i = 10;  
        getNumberCount(1);  
        System.out.println("onece i = " + i);  
  
        i = getNumberCount(i, 0);  
        System.out.println("twince i = " + i);  
    }  
  
    private static void getNumberCount(int i) {  
        i += 1;  
    }  
  
    public static int getNumberCount(int i, int j) {  
        return i += 1;  
    }  
}
```

## 其他问题 
### 枚举和String
就是，整体考虑场景问题，多系统交互下，String更为合适。单系统的某个模块下，枚举相对合适（枚举存放在常量池里，实际占用很小，加上JVM有优化，几千几万的量一般不影响内存占用（4c8g内存为例），极端情况是十万甚至百万才会产生影响）

## 参考链接
- [ Json和list的相互转换](https://blog.csdn.net/DeMonliuhui/article/details/52949079)
- [Json映射实体类](https://blog.csdn.net/qq_36147006/article/details/94733544)
- [Optional-掘金](https://juejin.cn/post/7343627002462912548?searchId=20240514174115DAB1D1ABC90B1415E00E#heading-12)
- [Optional用好了，缓解了多年NullPointerException恐惧](https://juejin.cn/user/4010652181733384/posts)
- [null 不好，我真的推荐你使用 Optional](https://juejin.cn/user/4406498336980103/posts)
- [还在用又臭又长的多层 if 判断空值？那我推荐你使用 Optional](https://juejin.cn/user/3257207932075799/posts)
- 









