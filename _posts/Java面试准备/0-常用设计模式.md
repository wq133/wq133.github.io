## 单例模式

单例模式具备典型的3个特点：
	1、只有一个实例。（不允许其他程序用new对象）
	2、自我实例化（ 在该类中创建对象）
	3、提供全局访问点。（对外提供一个可以让其他程序获取该对象的方法）
1. 饿汉式
```
public class SingletonEHan {  
  
    private SingletonEHan() {}  
  
    /**  
     * 1.单例模式的饿汉式[可用]  
     */    private static SingletonEHan singletonEHan = new SingletonEHan();  
  
    public static SingletonEHan getInstance() {  
        return singletonEHan;  
    }  
  
//     SingletonEHan instance= SingletonEHan.getInstance();
```
2. 含懒汉式
```
public class SingletonLanHan {
	/**  
	 * 6.单例模式懒汉式双重校验锁[推荐用]  
	 * 懒汉式变种,属于懒汉式的最好写法,保证了:延迟加载和线程安全  
	 */  
	private static SingletonLanHan singletonLanHanFour;  
	  
	public static SingletonLanHan getSingletonLanHanFour() {  
	    if (singletonLanHanFour == null) {  
	        synchronized (SingletonLanHan.class) {  
	            if (singletonLanHanFour == null) {  
	                singletonLanHanFour = new SingletonLanHan();  
	            }  
	        }  
	    }  
	    return singletonLanHanFour;  
	}
}
```

3. 内部类
```
/**  
 * Created by jingbin on 2016/10/28. * 7. 内部类[推荐用]  
 * <p>  
 * 这种方式跟饿汉式方式采用的机制类似，但又有不同。  
 * 两者都是采用了类装载的机制来保证初始化实例时只有一个线程。  
 * 不同的地方:  
 * 在饿汉式方式是只要Singleton类被装载就会实例化,  
 * 内部类是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类  
 * <p>  
 * 优点：避免了线程不安全，延迟加载，效率高。  
 */  
  
public class SingletonIn {  
  
    private SingletonIn() {  
    }  
    
	// 内部类
    private static class SingletonInHodler {  
        private static SingletonIn singletonIn = new SingletonIn();  
    }  
  
    public static SingletonIn getSingletonIn() {  
        return SingletonInHodler.singletonIn;  
    }  
}

```

4. 枚举
```
/**  
 * Created by jingbin on 2016/10/28. * 8. 枚举[极推荐使用]  
 * * 这里SingletonEnum.instance  
 * 这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。  
 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象  
 */  
  
public enum SingletonEnum {  
  
    instance;  
  
    private SingletonEnum() {  
    }  
  
    public void whateverMethod() {  
  
    }  
  
    // SingletonEnum.instance.method();  
  
}
```


## 工厂模式
1. 简单工厂
- 定义：通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

2. 工厂方法模式
- 定义：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式把类实例化的过程推迟到子类。

3. 抽象工厂模式

- 定义：提供一个接口，用于创建相关的或依赖对象的家族，而不需要明确指定具体类。


## 代理模式

> 一个类代表另一个类的功能。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。可以理解为内存中没有这个对象就创建，有就直接返回这个对象。

以获取磁盘中的图片为例，总共分三步：

- 1、创建一个接口。
    
    ```java
    public interface Image {
       void display();
    }
    ```
    
- 2、创建实现接口的实体类 RealImage。对应代理类：ProxyImage。
    
    ```java
    public class RealImage implements Image {
    
        private String fileName;
    
        public RealImage(String fileName) {
            this.fileName = fileName;
            loadFromDisk(fileName);
        }
    
        private void loadFromDisk(String fileName) {
            Log.e("RealImage", "loading " + fileName);
        }
    
        @Override
        public void display() {
            Log.e("RealImage", "Displaying " + fileName);
        }
    }
    ```
    
    ```java
    public class ProxyImage implements Image {
    
        private String fileName;
        private RealImage realImage;
    
        public ProxyImage(String fileName) {
            this.fileName = fileName;
        }
    
        @Override
        public void display() {
            if (realImage == null) {
                realImage = new RealImage(fileName);
            }
            realImage.display();
        }
    }
    ```
    
- 3、当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。
    
    ```java
    Image image = new ProxyImage("test_10mb.png");
    // 第一次是new的，图像从磁盘加载
    image.display();
    // 第二次取缓存，图像不需要从磁盘加载
    image.display();
    ```



## 策略模式


## 观察者模式
## 监听模式


## 装饰器模式

## 适配器模式