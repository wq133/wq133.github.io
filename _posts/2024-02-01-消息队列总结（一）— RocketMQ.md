---
layout: post
title: 消息队列总结（一）—— RocketMQ
subtitle: 主流MQ、高频面试点
date: 2024-01-27
author: Wu
header-img: ../article_img/kb_1.jpg
catalog: true
tags:
  - RocketMq
  - 消息队列
  - 部署
  - 八股文
---
### RocketMQ实现原理

1. **架构模型：** RocketMQ采用了主从架构，包括了多个组件：NameServer、Broker、Producer、Consumer。NameServer负责维护所有Broker的路由信息和消息的Topic信息，Broker负责存储消息和处理消息的读写请求，Producer负责生产消息并发送到Broker，Consumer负责订阅消息并从Broker消费消息。

2. **存储机制：** RocketMQ支持消息的持久化存储，消息在发送时先写入CommitLog（消息存储文件），然后根据Topic和消息属性进行索引。另外，RocketMQ还支持将消息存储在内存中，以提高消息的传输速度。

3. **消息传输：** RocketMQ支持同步和异步两种消息传输方式。同步发送时，Producer发送消息后会等待Broker的确认消息；异步发送时，Producer发送消息后不会等待确认消息，而是通过回调函数来处理发送结果。此外，RocketMQ还支持顺序消息传输，保证同一消息队列的消息按照发送顺序被消费。

4. **消息消费：** Consumer可以通过订阅特定的Topic来消费消息，RocketMQ支持广播模式和集群模式两种消费模式。广播模式下，每个Consumer都会接收到相同的消息；集群模式下，每个消息只会被一个Consumer消费。Consumer消费消息时，会先从NameServer获取Broker的路由信息，然后再向Broker发送拉取消息的请求。

5. **高可用性：** RocketMQ支持Broker的主备模式和多个NameServer节点来保证高可用性。当一个Broker宕机时，会自动切换到备用Broker上继续提供服务；当一个NameServer节点宕机时，Producer和Consumer可以通过其他NameServer节点来获取Broker的路由信息。

总的来说，RocketMQ的实现原理主要包括架构模型、存储机制、消息传输、消息消费和高可用性等方面，这些特点使得RocketMQ成为了一款高性能、高可用的分布式消息中间件。
## 主流MQ模型对比

| 消息中间件    | 优点                                    | 缺点                                      | 使用场景                  | 集群模式                                         |
| -------- | ------------------------------------- | --------------------------------------- | --------------------- | -------------------------------------------- |
| RabbitMQ | 功能全面、消息的可靠性比较高                        | 吞吐量低，消息大量积累会影响性能，使用的开发语言是erlang，不好定制功能。 | 规模不大的场景               | 支持简单集群，复制模式，对高级集群模式支持不好。                     |
| RocketMQ | 吞吐量高，性能高，可用性高，功能全面。使用Java语言开发，容易定制功能。 | 开源版不如阿里云上版，文档比较简单。                      | 几乎支持所有场景，包含大数据场景和业务场景 | 常用多对‘Master-Slave’模式，开源版本需要手动切换Slave到Master。 |
| Kafka    | 吞吐量最高性能最好，集群模式下高可用                    | 功能上比较单一，会丢失部分数据                         | 日志分析，大数据场景            | 天然Leader-Slave模式，每台服务器即是Master也是Slave。       |


## RocketMQ

### 一条消息的发送->消费流程

1. **生产者发送消息：** 生产者通过网络连接将消息发送到 RocketMQ Broker。在发送消息时，生产者需要指定要发送到的主题（Topic）以及消息的内容。

2. **Broker 接收消息：** RocketMQ Broker 接收到生产者发送的消息后，将其持久化存储到磁盘上，并将消息写入消息日志文件中。同时，消息会被放入消息队列中等待消费者消费。

3. **消费者消费消息：** 消费者从 RocketMQ Broker 订阅（推模式）感兴趣的主题，并定时拉取消息。当有消息可供消费时，消费者会从 Broker 获取消息并进行处理。

4. **消息消费成功：** 如果消息成功被消费者处理，并且处理过程中未发生异常，则认为消息已成功消费。

5. **消息消费失败：** 如果消息消费过程中发生异常，或者消费者无法处理消息，则认为消息消费失败。RocketMQ 提供了消息重试机制，可以在消费失败时重新消费消息，直到消息被成功处理或达到最大重试次数。(**异常处理策略在消费者消费消息的业务逻辑中，可以通过捕获异常并记录日志的方式来实现异常处理**。`maxReconsumeTimes=3`)

6. **消息存储和删除：** 当消息被成功消费后，RocketMQ 可以根据配置策略删除消息。如果配置了消息的保留时间或者磁盘空间限制策略，则在达到相应条件时，RocketMQ 会删除消息文件中的过期消息以释放空间。

### RocketMq的架构/rocketmq内部组件有什么？  
![](../article_img/RocketMq%20messageModel20240311170603.png)


RocketMQ主要由 Producer、Broker、Consumer 三部分组成

其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。

Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。

Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。

ConsumerGroup 由多个Consumer 实例构成。
#### 名字服务（Name Server）
名字服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。

#### 生产者（Producer）
主要是发送消息（一个消息生产者会把业务应用系统里产生的）到broker服务器。发送方式：（默认方式：异步发送）
- 同步发送：必须等到Broker反馈之后才能继续发，安全性最⾼但发消息最 慢
- 异步发送：生产者发送消息后不会阻塞等待消息发送的响应，是继续执行后续代码。同时，生产者会注册一个回调函数，在消息发送完成后会调用该回调函数来处理发送结果，无论消息发送成功还是失败。
- 顺序发送：消息生产者可以保证同一业务标识（比如同一个订单号）的消息发送到同一个消息队列中，从而保证消息的消费顺序。场景：订单处理、日志处理。
- 单向发送：不需要Broker返回确认信息，不关系是否发送成功。场景：日志采集

#### 消费者（Consumer）
消费者默认通过**拉取式**获取消息，从broker端服务器拉取消息、并将其提供给应用程序，属于后台系统负责的**异步消费模式**。

**consumer获取消息形式：**
- 拉取式
- 推动式
**consumer消费消息的方式**：
- **同步消费：** 消费者在拉取消息后会阻塞等待消息处理完成，直到处理完当前消息后再拉取下一条消息。在同步消费模式下，消息的消费和处理是同步进行的，即消费者处理完当前消息后才能处理下一条消息。
- **异步消费：** 消费者在拉取消息后不会阻塞等待消息处理完成，而是通过注册回调函数来处理消息。当消费者获取到消息后，会异步地调用注册的回调函数进行消息处理。在异步消费模式下，消费者可以并行地处理多个消息，提高系统的并发处理能力。

**关于消费者的心跳机制：**
在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。

**推/订阅模式和拉取消费的区别**：
1. 推/订阅模式是broker主动去发送消息给订阅指定topic 的消费者。
2. 拉取消费是消费者主动发起请求拉取broker端消费队列中的信息。

推模式其实是对拉模式的一种封装，对服务器负载压力较大，所以有mq在client端有做负载均衡（核心是 在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列）。

**场景**：
- 如果需要**实时获取消息并进行处理**，可以选择推模式/订阅。
- 如果消费者对消息**处理速度**有较高要求，或者需要根据自身负载情况来控制消息消费速度，则可以选择拉取消费模式。


#### 主题（Topic）

表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。一般是用来区分不同的业务模块。

#### 代理服务器（Broker Server）

消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。


#### 生产者组（Producer Group）

同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。

#### 消费者组（Consumer Group）

同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。


### 消息模型
#### 顺序消息
顺序消息只能保证**局部消息有序**，不能保证全局有序，实现全局 有序 可以 ⽣产端将⼀批消息有序发往MessageQueue，消费端通 过锁队列的⽅式，每次只拿⼀个MessageQueue⾥的消息

#### 广播消息
⼴播消息并没有特定的消费者，因为这涉及到消费者的集群消费 模式，默认是集群模式

- 集群模式
1. 一条消息只会背一个消费者组中的一个消费者消费
**如何确保一条消息只被一个消费者消费**？
Broker会给每一个消费者组维护一个统一的offset来保证每一个组中的一条消息只会被消费一次。
- 广播模式
1. 一个消息会被推送给所有的消费者
broker只负责消息分发，所有的消费者自己保证offset的设置

#### 延迟消息
**定时消息/延迟队列** 是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。
通过配置broker的配置项messageDelayLevel，总共有18个level（1s-2h）。

发送消息时msg.setDelayLevel(level)来设置延迟时间。

定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，相同延迟时间的消息存储在同一个消息队列中。这个topic是特殊的定时队列，然后Broker上的定时消息调度器会定期检查消息是否到时间被投递。

1. **第一次写入：** 当你发送一个定时消息时，该消息首先被写入专门的定时消息Topic，这时会增加发送数量和TPS的计数。
2. **第二次调度写入真实Topic：** 当定时任务触发，定时消息需要实际发送到业务Topic时，也会增加发送数量和TPS的计数。这是因为在这个阶段，消息被调度并发送到真实的业务Topic中。

#### 批量消息
只能对同⼀topic下的消息进⾏批量发送，不⽀持延迟消息，以及 批量消息的⼤⼩不超过1MB，超过了需要⾃⾏拆分。

#### 过滤消息
RocketMQ分布式消息队列的消息过滤方式有别于其它MQ中间件，是在Consumer端订阅消息时再做消息过滤的。RocketMQ这么做是在于其Producer端写入消息和Consumer端订阅消息采用分离存储的机制来实现的，Consumer端订阅消息是需要通过ConsumeQueue这个消息消费的逻辑队列拿到一个索引，然后再从CommitLog里面读取真正的消息实体内容，所以说到底也是还绕不开其存储结构。其ConsumeQueue的存储结构如下，可以看到其中有8个字节存储的Message Tag的哈希值，基于Tag的消息过滤正是基于这个字段值的。
![](../article_img/RocketMqConsumeQueue%2020240311175103.png)

区分为Tag过滤和SQL92过滤。

Tag过滤流程：
1. Consumer端在订阅消息时除了指定Topic还可以指定TAG，如果一个消息有多个TAG，可以用||分隔。
2. 其中，Consumer端会将这个订阅请求构建成一个 SubscriptionData，发送一个Pull消息的请求给Broker端。
3. Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter(消息过滤器)，然后传给Store。
4. Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。
5. 使用哈希桶和链表的形式来解决hash冲突。

#### 事务消息
RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。

这意味着只有在本地事务执行成功且状态确认的情况下，消息才会被正常地投递给消息消费者。如果本地事务执行失败或者状态未知，消息将被**回滚**，不会被投递。
这样就确保了**消息系统的数据一致性**。

RocketMQ事务消息的详细流程：

1. **发送事务消息：** 应用程序通过调用RocketMQ的事务消息发送API发送事务消息。发送事务消息时，RocketMQ会为该消息生成一个唯一的半消息（Half Message）。

2. **执行本地事务：** 发送事务消息后，RocketMQ会回调应用程序的本地事务执行方法（TransactionListener#executeLocalTransaction）。在这个方法中，应用程序需要执行本地业务逻辑，并返回一个表示本地事务执行结果的状态。

3. **事务状态回查：** 在发送事务消息后，RocketMQ会定期检查本地事务的执行状态。这通过回调应用程序的另一个方法（TransactionListener#checkLocalTransaction）来实现。在这个方法中，应用程序需要告诉RocketMQ本地事务的执行状态，即是提交、回滚还是未知。

4. **消息二次确认：** 如果本地事务执行成功，并且在事务状态回查时返回提交状态，RocketMQ会二次确认半消息，将其标记为可投递状态。这样，消息将会被投递到消息消费者。

5. **消息回滚：** 如果本地事务执行失败或者在事务状态回查时返回回滚状态，RocketMQ会回滚半消息，将其标记为不可投递状态。这样，消息将不会被投递到消息消费者。

### 消息存储原理 / 持久化机制
![](../article_img/RocketMqsaveModel%2020240312222514.png)

生产者把消息发到Broker时，会把消息放到commitLog中去，通过查找消息对应的offset（起始物理偏移量），类似于hashmap的方式，通过offset索引找到 保存在指定Topic下的队列消息。
#### commitlog
- CommitLog⽂件由多个⽂件组成，以⾸条消息的**offset**作为⽂ 件名
- 单个文件最⼤消息固定默认1G，可以⽅便消息刷到内存 
- 对于采⽤分段存储，有助于并⾏读取消息 
- 对于消息的offset，消费端可以通过指定offset去拉取指定消息，不会影响到别的消费者

对比Kafka 还需要定位分区⽂件(top + 分区号)才能进⾏写⼊，减少了定位⽬标⽂件的时间，所以Kafka不 适合过多Topic的场景 

#### 页缓存和内存映射

页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。

一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。

在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。
**而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。** 如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。

另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的**FileChannel**模型将磁盘上的物理文件直接映射到用户态的内存地址中（减少传统磁盘间拷贝来回进行拷贝内存地址的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。
- 减少性能开销
- 提高读写效率


#### 消息刷盘
![](../article_img/Pasted%20image%2020240312233145.png)
RocketMQ采⽤了 **异步刷盘和定期刷盘相结合** 的⽅式来提⾼写⼊性能
- 异步刷盘是指消息⾸先写⼊内存缓冲区，然后由后台线程定期将 内存中的数据刷写到磁盘 
- 定期刷盘是指RocketMQ会定期触发刷盘操作，将内存中的数据刷 写到磁盘

另外刷盘策略有同步和异步两种。
- 同步刷盘：如上图所示，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。

- 异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。

#### Broker端采⽤⼀主多从⾼可⽤模式
主负责写，从 负责备份，如果主出现故障，从节点会⾃动切换为主节点。

### 消息重试
 消费者端采⽤**状态确认机制**保证消费者⼀定能正常处理对应的消息 
- Broker会通过记录重试次数，为了不影响topic下其它正常的消 息，会给每个消费组设计对应的重试topic，在消息重试时，会将 原topic的消息移动到对应的重试topic中去。
- 当重试达到⼀定阈值 会将失败的消息推⼊到死信topic中 消费者组由多个消费者实例组成，Broker只需要向某⼀个实例推 送消息即可，保障消息重试机制正常运⾏
- 并且Broker只通过消 费者返回的状态来判断是否处理成功，但是业务执⾏是否正确是 ⽆法知道的。（消费者也可以⾃⾏指定起始消费位点 Broker通过消费者返回的状态来推进消费者组对应的消息offset， 虽然offset是Broker来维护，但是消费者可以⾃⼰指定offset进⾏ 消费）

### 死信队列
RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。
1. 当一条消息初次消费失败，消息队列会自动进行消息重试；
2. 达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。

在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。




### 过期文件删除机制

**如何判断过期文件？**
通过判断文件最后修改的时间和消息存储时间，超过 `fileReservedTime`就会被标记为过期文件，并在下一次过期文件清理任务中进行清理操作。消息也会由于消息未消费导致消息丢失。

broker端配置的broker.conf下的参数来控制
1. `fileReservedTime` ：参数来设置消息文件的保留时间，单位为小时。
2. **deleteWhen**：该参数用于配置消息文件的删除时间策略。它有以下几个可选值：
- `interval`：间隔删除策略，表示每隔一段时间删除一次过期文件。
- `time`：时间删除策略，表示每天固定时间删除一次过期文件。
- `immediately`：立即删除策略，表示消息被标记为过期后立即删除。
3. **deleteWhenEveryDay**：当 `deleteWhen` 参数设置为 `time` 时，该参数用于指定删除过期文件的时间点。它的值为一个时间字符串，例如 `04:00` 表示凌晨 4 点删除过期文件。
4. **diskMaxUsedSpaceRatio**：该参数用于设置磁盘空间的使用率阈值，单位为百分比。当磁盘空间使用率超过该阈值时，RocketMQ 会触发删除过期文件的操作，以释放磁盘空间。
5. **maxMessageSize**：该参数用于设置消息的最大大小，单位为字节。当消息超过设定的大小时，RocketMQ 可能会将其丢弃或拒绝接收。

RocketMQ中默认凌晨4点执⾏定时任务进⾏⽂件扫描，触发过期 ⽂件删除操作，如果磁盘空间不充⾜也会触发，所以官⽅建议 Broker的磁盘空间不能少于4G。

## [部署实践](https://github.com/apache/rocketmq/blob/master/docs/cn/operation.md)
## 主从复制原理


## 常见问题：

### 为什么要使用MQ
1. **异步解耦：** 消息队列可以将系统内部的各个模块解耦，使得消息的发送和接收方不需要直接相互依赖或者知道彼此的存在。通过消息队列，系统中的不同模块可以异步地进行通信和交互，提高系统的灵活性、可扩展性和可维护性。

2. **削峰平谷：** 在高并发场景下，消息队列可以平滑处理突发的请求量，将峰值流量转化为稳定的消息队列流量，从而保护系统的稳定性和可用性。通过消息队列，可以将请求缓存到队列中，然后由消费者按照自身的处理能力逐渐消费，避免因突发流量导致系统崩溃或服务不可用的情况。

3. **解耦和扩展性：** 使用消息队列可以将系统内部的各个模块解耦，降低模块之间的耦合度，提高系统的灵活性和扩展性。当系统需要新增功能或者修改业务逻辑时，可以通过添加新的消息队列或者调整消息队列的消费者来实现，而不需要对系统的其他部分进行修改。

4. **异步处理：** 使用消息队列可以将耗时的操作和异步任务放到消息的消费者端进行处理，从而提高系统的响应速度和吞吐量。通过异步处理，可以将不需要立即返回结果的操作放到后台异步执行，减少用户的等待时间，提升用户体验。

5. **消息传递可靠性：** 消息队列通常提供消息持久化、消息确认和消息重试等机制，保证消息的可靠传递。即使在消息发送或消费过程中出现网络故障或者系统崩溃的情况下，消息队列也能够确保消息不会丢失，并且能够保证消息的顺序性。

综上所述，使用消息队列（如RocketMQ）可以提高系统的异步解耦能力、削峰平谷能力、解耦和扩展性、异步处理能力以及消息传递的可靠性，从而提升系统的稳定性、可用性和性能。

### 如果让你不用mq，你自己设计一个你会怎么设计？
如果不使用消息队列，我可能会考虑设计一个基于事件驱动的分布式系统，以下是我的设计思路：

1. **事件驱动架构：** 系统采用事件驱动的架构，各个模块之间通过发布和订阅事件来进行通信。每个模块都可以是一个事件的生产者或者消费者，根据自己的业务逻辑来发布或者订阅相关的事件。

2. **事件中心：** 设计一个事件中心（Event Center），负责管理和调度各个模块之间的事件通信。事件中心可以是一个独立的服务或者模块，负责接收、分发和处理各种事件。

3. **事件定义：** 在系统中定义各种业务事件，例如订单创建、支付成功、库存更新等事件。每个事件都包含一些必要的信息，例如事件类型、触发时间、相关数据等。

4. **事件生产者：** 系统中的各个模块根据自己的业务逻辑来产生事件，并将事件发布到事件中心。事件生产者负责生成事件，并将事件发送到事件中心。

5. **事件消费者：** 系统中的各个模块根据自己的业务逻辑来消费事件，并对事件进行相应的处理。事件消费者订阅感兴趣的事件，并从事件中心接收并处理这些事件。

6. **事件路由和过滤：** 事件中心根据事件的类型和内容，将事件路由到对应的消费者，并进行事件过滤和路由优化。事件中心可以根据订阅关系、事件类型和消费者的负载情况来决定事件的分发策略。

7. **容错和可靠性：** 设计事件中心具有容错和可靠性的特性，保证事件的可靠传递和处理。例如，采用消息持久化、消息重试和消息确认机制来确保事件不会丢失，以及对消费者的负载均衡和故障恢复机制来保证系统的稳定性。

8. **监控和管理：** 设计监控和管理系统，实时监控事件中心和各个模块的运行状态，包括事件的产生、传递和消费情况，以及及时处理系统中的异常情况和故障。

通过以上设计，可以实现一个基于事件驱动的分布式系统，实现模块之间的**解耦、异步通信和削峰平谷**等功能，提高系统的灵活性、可扩展性和可维护性。


#### 用redis如何实现一个MQ(消息队列)?

我们使用了redis中的list类型实现的。

当生产者发消息时，就往redisi这个list push这个消息。然后消费者使用消息就将这个消息pop出来就行了。redis中使用持久化策略保证消

息不丢失。生产者那边将push出错的写入日志，重新push。消费者那边也是一样。


你可以使用 Redis 来实现一个简单的消息队列（MQ），下面是一个基本的设计思路：

1. **使用列表存储消息：** 在 Redis 中使用列表（List）来存储消息队列。每个队列对应一个列表，消息按照先进先出（FIFO）的顺序排列在列表中。

2. **生产者向队列添加消息：** 生产者向指定队列的列表尾部添加消息，可以使用 Redis 的 leftPush命令将消息添加到列表中。

3. **消费者从队列获取消息：** 利用redis自带的BlockingDeque，消费者从指定队列的列表头部获取消息，可以使用 Redis 的 rightPop 命令从列表中弹出消息。如果列表为空，BRPOP 命令会阻塞等待直到有消息可用。

4. **消息持久化：** 可以选择将消息持久化到磁盘，以防止消息丢失。可以使用 Redis 的持久化机制，如RDB 或者 AOF，将消息保存到磁盘中。

5. **多个消费者情况下的消息处理：** 在多个消费者同时消费同一个队列的情况下，Redis 的 BRPOP 命令是阻塞的，会保证只有一个消费者可以获取到消息，确保消息不会被重复消费。

6. **消息确认机制：** 可以实现一个简单的消息确认机制，当消费者处理完消息后向 Redis 发送确认消息的命令，从而将消息从队列中移除。

7. **消息超时处理：** 可以实现一个简单的消息超时机制，当消息在队列中的时间超过一定的阈值后自动移除，以避免消息积压导致队列过长。

8. **监控和管理：** 可以实现监控和管理功能，实时监控消息队列的状态、队列长度和消费者的消费情况，及时处理异常情况和故障。


通过以上设计，你可以利用 Redis 实现一个简单的消息队列（MQ），用于在应用程序中实现异步通信、削峰平谷等功能。需要注意的是，这只是一个简单的实现方式，如果需要更高级的特性（如 消息持久化、消息确认、消息重试等），可能需要更复杂的设计和实现

### 消息局部顺序是如何保证的？
MQ的顺序包含局部有序和全局有序 
- 局部有序:(只保证⼀部分消息链路消费有序) ⽣产端可以通过消息选择器指定发送到某个MessageQueue， 从⽽保证局部有序。
- 全局有序:(整个消息链路严格按照先进先出的顺序进⾏消费) 要保证全局有序就必须牺牲吞吐量，也就是⼀个topic只能有⼀个 MessageQueue被消费(默认4个)，可以通过锁队列的⽅式进⾏消 费，保证全局有序


**锁队列：**
为了确保全局有序消费，RocketMQ 提供了一种称为“锁队列”的机制。具体来说，当消费者获取到某个队列的消息时，会尝试获取该队列的独占锁，从而保证在同一时刻只有一个消费者能够消费该队列的消息。这样就避免了多个消费者并发消费同一个队列的消息，保证了消息的全局有序性。

在 RocketMQ 中，默认情况下，一个主题（Topic）会被分配多个消息队列（通常是 4 个），不同的消息队列可以并行地被多个消费者消费。但是，如果需要保证全局有序消费，则可以通过配置来将该主题设置为单队列模式，从而确保只有一个消息队列给消费者消费。

需要注意的是，锁队列的方式会牺牲一定的吞吐量，因为在同一时刻只有一个消费者能够消费消息。

1. **单一队列保证顺序：** 将所有的消息发送到同一个队列中，并确保消费者按照消息的顺序进行消费。这种方法可以保证全局有序性，但是可能会成为系统的瓶颈，因为所有的消息都需要经过同一个队列。

2. **分区有序：** 将消息按照一定的规则（如消息的关键字或者消息的哈希值）分发到多个队列中，然后在每个队列中保持消息的有序性。这种方法可以减轻单一队列的压力，但是需要消费者能够根据规则订阅到正确的队列。

3. **分布式事务：** 在生产者端使用分布式事务来保证消息的顺序性，确保相关的消息在同一个事务中发送，这样就可以保证消息的顺序性。但是分布式事务的实现会增加系统的复杂度和开销。

4. **消息标识：** 在消息的头部添加序列号或者时间戳等标识，消费者在接收消息时可以根据标识来验证消息的顺序性。这种方法可以在一定程度上保证消息的顺序性，但是可能会增加消息的大小和传输开销。

5. **全局锁机制：** 使用全局锁机制来保证对消息队列的操作是串行的，确保消息的顺序性。这种方法可以在一定程度上保证消息的顺序性，但是会降低系统的并发性能。

### 消息重复消费，幂等性问题

**什么是幂等性？**
幂等性：无论操作多少次最终结果的一致性。
重复消费无论多少次，都要保证不会对消费一次的结果产生影响。
**解决方案**：
1. **消息去重：** 在消息生产者端，可以在发送消息之前对消息进行去重处理，通过redis+**唯一标识符** 自增校验去重（例如消息 ID）来判断消息是否已经发送过，如果已经发送过，则不再发送。
2. 消息消费之前db中的消费记录的校验（慢）。
3. 使用事务消息。

可以基于Redis + 业务唯⼀ID来解决 消费前判断Redis中是否存在，如果存在就跳过，如果不存在就存 ⼊Redis 。⽐如使⽤分布式锁进⾏幂等性处理


### 如何防止消息丢失？
（从生产者，服务端和消费者三方面讲讲。）

**服务端：**
对于跨⽹络的节点可能会丢消息，因为MQ存盘都会先写⼊OS的 **PageCache**中，然后再让OS进⾏**异步刷盘**，如果缓存中的数据未及时 写⼊硬盘就会导致消息丢失。

**⽣产端到Broker端：**
生产端发送方式使用同步发送，利用消息重发机制保证数据发送成功。不使用异步发送，保证安全性。不使用单向发送，无法确认发送成功及保证安全性。
异步发送/单向的安全性问题？
- 生产者无法对发送失败的情况进行及时处理（处理包括 **重发、告警提示、错误日志记录、消息队列的监控管理**等）。
- 无法确认消息发送成功失败，影响后续代码逻辑的业务交互
- 异步发送方式无法保证消息到达broker端端顺序性。 

**Broker端持久化：**
 采⽤**同步刷盘**以及**2PC两阶段提交**，来保证同步时不会丢消 息。
 but异步刷盘⼀断电就会丢消息。


**Broker端到消费端：**

采⽤同步消费机制，不要使⽤异步消费机制
- 在同步消费情况下，消费完消息之后再去给Broker端反 馈，然后Broker端会去维护消息偏移量，如果消费失败可 以进⾏⼀定次数的重试。
- 在异步消费情况下，消费完消息的同时也会向Broker端反馈，然后Broker端会去维护消息偏移量；如果仍然消费失败，不会进⾏重试因为偏移量已经变更；

**其他方案：**
另外RocketMQ服务需要有降级⽅案，对于RocketMQ来说， NameServer挂了，本身就⽆法保证消息不丢失了，所以应对这种场 景，我们可以使⽤**服务降级**⽅案，将消息暂存到Redis、⽂件或内存 中，等MQ服务恢复之后再将消息转移过去。

### rocketmq如何提高吞吐量/如何处理大量消息的堆积？
例如生产者生产很多消息，**消费者组这边要如何消费去平衡消息的堆积**，并发消费问题等？  

思路：从producer和broker、consumer三者出发优化。利用rocketmq在clinet端的producer和consumer的负载均衡机制去分析。

生产者：优化生产者批量发送消息的大小、调整发送间隔参数（通过调整这个以毫秒为单位的一个时间间隔的数值，结合监控平台设置合理参数。）、

broker：增加broker实例数量。

消费者：集群模式下consumer端会用一个消息队列分配策略算法对消息进行类似分页平均对操作，索引我们想要提高吞吐量，**增加消费者实例**，或者对于这个消息队列的分配策略算法作出调整，优先利用空闲队列（**重写分配算法**）。再有就是合理优化消费者配置参数，比如**消费线程数调整、批量拉取消息的大小**。

系统层面：消息预取和预拉取

代码层面：优化消息处理逻辑


1. **增加 Broker 数量：** 增加 Broker 数量可以增加消息队列的分布和负载均衡，从而提高整体系统的吞吐量。通过水平扩展 Broker，可以使系统能够处理更多的消息并发。

2. **优化生产者配置：** 生产者可以通过调整发送消息的批量大小、发送间隔等参数来优化发送性能。合理配置生产者的参数可以提高消息的发送效率，进而提高整体吞吐量。

3. **优化消费者配置：** 消费者可以通过调整消费线程数、拉取消息的批量大小等参数来优化消费性能。合理配置消费者的参数可以提高消费速度，有效消费掉堆积的消息，从而平衡消息的堆积问题。

4. **增加消费者实例：** 增加消费者实例可以增加消费者的并发处理能力，从而提高消费速度。通过增加消费者实例，可以平衡消息的堆积问题，并加快消息的处理速度。

5. **消费者组动态调整：** 根据实际情况动态调整消费者组的消费者数量和配置，以适应消息负载的变化。可以根据系统的负载情况和消息堆积情况动态调整消费者组的消费者数量，使消费者能够有效地消费掉堆积的消息。

6. **消息预取和预拉取：** 消费者可以采用消息预取和预拉取的方式来提高消费速度。通过预先拉取消息并缓存到本地，消费者可以减少拉取消息的延迟，并提高消息的处理效率。

7. **优化消息处理逻辑：** 消费者可以优化消息处理逻辑，尽量减少处理消息的时间，提高消费速度。可以采用多线程并发处理消息，或者采用异步处理的方式来提高处理效率。


### 谈谈你对RocketMQ分布式事务原理的理解 
- 分布式事务 就是在分布式环境下，需要保证不同服务的数据⼀致性 
- 分布式事务的实现⽅式可以基于2PC两阶段提交
1. 准备阶段，协调者通知参与者准备提交各⾃的事务 
2. 提交阶段，参与者反馈，协调者通过反馈去决定执⾏**事务提交**或 **回滚**

