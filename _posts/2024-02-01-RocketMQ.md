---
layout: post
title: MQ总结
subtitle: 主流MQ、高频面试点
date: 2024-01-27
author: Wu
header-img: ../article_img/kb_1.jpg
catalog: true
tags:
  - Redis
  - 八股文
---

## 主流MQ模型对比

| 消息中间件    | 优点                                    | 缺点                                      | 使用场景                  | 集群模式                                         |
| -------- | ------------------------------------- | --------------------------------------- | --------------------- | -------------------------------------------- |
| RabbitMQ | 功能全面、消息的可靠性比较高                        | 吞吐量低，消息大量积累会影响性能，使用的开发语言是erlang，不好定制功能。 | 规模不大的场景               | 支持简单集群，复制模式，对高级集群模式支持不好。                     |
| RocketMQ | 吞吐量高，性能高，可用性高，功能全面。使用Java语言开发，容易定制功能。 | 开源版不如阿里云上版，文档比较简单。                      | 几乎支持所有场景，包含大数据场景和业务场景 | 常用多对‘Master-Slave’模式，开源版本需要手动切换Slave到Master。 |
| Kafka    | 吞吐量最高性能最好，集群模式下高可用                    | 功能上比较单一，会丢失部分数据                         | 日志分析，大数据场景            | 天然Leader-Slave模式，每台服务器即是Master也是Slave。       |


## RocketMQ

### RocketMq的消息模型/rocketmq内部组件有什么？  
RocketMQ主要由 Producer、Broker、Consumer 三部分组成

其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。

Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。

Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。

ConsumerGroup 由多个Consumer 实例构成。

#### 生产者（Producer）
主要是发送消息（一个消息生产者会把业务应用系统里产生的）到broker服务器
发送方式：
- 同步发送
- 异步发送
- 顺序发送
- 单向发送
同步和异步方式均需要Broker返回确认信息，单向发送不需要。

#### 消费者（Consumer）
一般是后台系统负责异步消费。
一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。
用户视角的消费形式：
- 拉取式消费
- 推动式消费。

#### 主题（Topic）

表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。

#### 代理服务器（Broker Server）



消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。

#### 名字服务（Name Server）
名字服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。

#### 生产者组（Producer Group）

同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。

#### 消费者组（Consumer Group）

同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。







## [部署实践](https://github.com/apache/rocketmq/blob/master/docs/cn/operation.md)


## 常见问题：

### 消息局部顺序是如何保证的？

### 消息重复消费，幂等性问题

### rocketmq如何提高吞吐量，例如生产者生产很多消息，消费者组这边要如何消费去平衡消息的堆积，并发消费问题等？  


### 如何防止消息丢失？从生产者，服务端和消费者三方面讲讲。



